#include<iostream>
using namespace std;

// Node class to represent each node in BST
class node {
public:
    int data;
    node *left;
    node *right;
};

// BST class encapsulating operations on the Binary Search Tree
class BST {
public:
    node *root;
    int cnt;

    BST() {
        root = NULL;
        cnt = 0;
    }

    void insert();                  // Insert node
    void inorder(node *temp);      // Inorder traversal
    void smallest();               // Find smallest value
    void largest();                // Find largest value
    int search(int key);           // Search a node
    void Mirror(node *r);          // Create mirror image
    int height(node *r);           // Find height of tree
};

// Calculate height of the tree (longest path from root)
int BST::height(node *r) {
    if (r == NULL)
        return 0;

    int Left_Height = height(r->left);
    int Right_Height = height(r->right);

    return max(Left_Height, Right_Height) + 1;
}

// Mirror the tree (swap left and right at every node)
void BST::Mirror(node *r) {
    if (r != NULL) {
        swap(r->left, r->right);
        Mirror(r->left);
        Mirror(r->right);
    }
}

// Search a value in the BST
int BST::search(int key) {
    node *temp = root;
    while (temp != NULL) {
        if (key < temp->data)
            temp = temp->left;
        else if (key > temp->data)
            temp = temp->right;
        else
            return 1;  // Found
    }
    return 0;  // Not found
}

// Find smallest element (left-most node)
void BST::smallest() {
    node *temp = root;
    while (temp->left != NULL)
        temp = temp->left;
    cout << "\nSmallest node in the tree is: " << temp->data;
}

// Find largest element (right-most node)
void BST::largest() {
    node *temp = root;
    while (temp->right != NULL)
        temp = temp->right;
    cout << "\nLargest node in the tree is: " << temp->data;
}

// Insert a new node into BST
void BST::insert() {
    node *new_node = new node();
    new_node->left = NULL;
    new_node->right = NULL;

    cout << "Enter data: ";
    cin >> new_node->data;

    if (root == NULL) {
        root = new_node;
        return;
    }

    node *temp = root;
    while (true) {
        if (new_node->data < temp->data) {
            if (temp->left == NULL) {
                temp->left = new_node;
                break;
            } else {
                temp = temp->left;
            }
        } else if (new_node->data > temp->data) {
            if (temp->right == NULL) {
                temp->right = new_node;
                break;
            } else {
                temp = temp->right;
            }
        } else {
            cout << "\nData already exists in the tree.";
            break;
        }
    }
}

// Inorder traversal (Left, Root, Right)
void BST::inorder(node *temp) {
    if (temp != NULL) {
        inorder(temp->left);
        cout << " " << temp->data;
        cnt++;
        inorder(temp->right);
    }
}

// Main function with menu to demonstrate all BST operations
int main() {
    int ch;
    BST B;

    do {
        cout << "\n\n--- Menu ---";
        cout << "\n1. Insert";
        cout << "\n2. Inorder Traversal";
        cout << "\n3. Find Smallest Number";
        cout << "\n4. Find Largest Number";
        cout << "\n5. Search Value";
        cout << "\n6. Mirror the Tree";
        cout << "\n7. Find Height of Tree";
        cout << "\n8. Exit";
        cout << "\nEnter your choice: ";
        cin >> ch;

        switch (ch) {
            case 1:
                B.insert();
                break;
            case 2:
                B.cnt = 0;  // Reset count
                B.inorder(B.root);
                cout << "\nTotal nodes visited (Inorder): " << B.cnt;
                break;
            case 3:
                B.smallest();
                break;
            case 4:
                B.largest();
                break;
            case 5: {
                int key;
                cout << "Enter value to search: ";
                cin >> key;
                if (B.search(key))
                    cout << "Value found in tree.";
                else
                    cout << "Value not found.";
                break;
            }
            case 6:
                B.Mirror(B.root);
                cout << "Tree mirrored successfully.";
                break;
            case 7:
                cout << "Height of the tree: " << B.height(B.root);
                break;
            case 8:
                cout << "Exiting program.";
                break;
            default:
                cout << "Invalid choice. Try again.";
        }
    } while (ch != 8);

    return 0;
}

/*
Best/Average: O(log n) for balanced BST
Worst: O(n) for skewed tree
Q: What is a mirror of a tree?
A: A mirror swaps left and right pointers of all nodes in the tree recursively.

Q: Can a BST be perfectly balanced?
A: Only if the number of nodes is such that all levels are completely filled except possibly the last.

Q: What is a skewed BST?
A: A tree where all nodes form a straight line (either left or right). Worst-case time complexity is O(n).

Q: How do you prevent a skewed BST?
A: Use self-balancing trees like AVL or Red-Black Trees.

Q: What are real-world applications of BST?
A: Symbol tables, map/set implementations, database indexing, and router tables.
*/
